{
    "docs": [
        {
            "location": "/",
            "text": "Ionide\n\n\nIonide is a \nVisual Studio Code\n package suite for cross platform F# development.\n\n\nOverview\n\n\nIonide for VSCode is set of 3 plugins avaliable in VSCode marketplace.\n\n\n\n\n\n\nIonide-fsharp\n - provides F# specific features including advanced editor features (autocomplete, go-to definition, tooltips, rename, various refactorings and quick fix suggestions), integration with .Net project system, project explorer for project file visualization and manipulation, integration with MsBuild for building and running applications, debugger integration and more.\n\n\n\n\n\n\nIonide-Paket\n - provides integration with Paket - package dependency manager for .NET with support for NuGet packages and GitHub repositories.\n\n\n\n\n\n\nIonide-FAKE\n - FAKE (F# Make) is popular F# tool and DSL for build orchestration.\n\n\n\n\n\n\nRequirements\n\n\n\n\n\n\nVisual Studio Code - it is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux created by Microsoft. For detailed documentation of editor, getting-started guides and more visit \nofficial documentation\n.\n\n\n\n\n\n\nF# - it is a mature, open source, cross-platform, functional-first programming language. It empowers users and organizations to tackle complex computing problems with simple, maintainable and robust code. Ionide supports any version of F# >= 3.0 but we do recommend using F# 4.1. Detailed installation instructions can be found of F# Software foundation webpage - for \nWindows\n, \nMacOS\n, and \nLinux\n\n\n\n\n\n\n.Net Core SDK - .Net Core is lightweight, cross platform, modern implementation of .Net Framework. We strongly recommend installing it since some advanced Ionide features such as debugging and project scaffolding depends on SDK and \ndotnet\n CLI tooling even if your application is targetting Full Framework. For detailed instructions on installing .Net Core visit \nofficial step-by-step installation guide\n\n\n\n\n\n\nVSCode C# plugin (optional) - Ionide's debugging capabilities relies on the debugger provided by Omnisharp team. To get it install \nC# extension from VSCode marketplace\n\n\n\n\n\n\nMsBuild 2015 (Windows only, optional) - For old, verbose \n.fsproj\n files on Windows MsBuild 2015 (14.0) needs to be additionally installed. You can download it \nhere\n. However, we highly recommend using new, SDK-based project files.\n\n\n\n\n\n\nPlugin installation\n\n\nAny VSCode extension can be installed using UI just inside VSCode. Bring up the Extensions view by clicking on the Extensions icon in the Activity Bar on the side of VS Code or the \nView: Extensions\n command (\nCtrl+Shift+X\n). Then in search box type \nIonide\n to find all 3 extensions we provide. Click the \nInstall\n button and after a successful install, you'll see an \nReload\n button which will prompt you to restart VS Code to enable the new extension. For more detailed information about plugin installation visit \nVSCode documentation\n\n\nPlugin activation\n\n\nVSCode plugins are running in external processes (which means they should never impact editor performance) and are activated lazily, when certain activation events happens. This means that plugins are not loaded unnecesserly, for example when you don't work on project using given programming language.\n\n\nIonide plugins are activated when:\n\n\n\n\n\n\nOpened workspace contains any \n.fsproj\n, \n.fs\n, or \n.fsx\n file\n\n\n\n\n\n\nNew \n.fsproj\n, \n.fs\n, or \n.fsx\n file is created in workspace that was not containing those files before.",
            "title": "Home"
        },
        {
            "location": "/#ionide",
            "text": "Ionide is a  Visual Studio Code  package suite for cross platform F# development.",
            "title": "Ionide"
        },
        {
            "location": "/#overview",
            "text": "Ionide for VSCode is set of 3 plugins avaliable in VSCode marketplace.    Ionide-fsharp  - provides F# specific features including advanced editor features (autocomplete, go-to definition, tooltips, rename, various refactorings and quick fix suggestions), integration with .Net project system, project explorer for project file visualization and manipulation, integration with MsBuild for building and running applications, debugger integration and more.    Ionide-Paket  - provides integration with Paket - package dependency manager for .NET with support for NuGet packages and GitHub repositories.    Ionide-FAKE  - FAKE (F# Make) is popular F# tool and DSL for build orchestration.",
            "title": "Overview"
        },
        {
            "location": "/#requirements",
            "text": "Visual Studio Code - it is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux created by Microsoft. For detailed documentation of editor, getting-started guides and more visit  official documentation .    F# - it is a mature, open source, cross-platform, functional-first programming language. It empowers users and organizations to tackle complex computing problems with simple, maintainable and robust code. Ionide supports any version of F# >= 3.0 but we do recommend using F# 4.1. Detailed installation instructions can be found of F# Software foundation webpage - for  Windows ,  MacOS , and  Linux    .Net Core SDK - .Net Core is lightweight, cross platform, modern implementation of .Net Framework. We strongly recommend installing it since some advanced Ionide features such as debugging and project scaffolding depends on SDK and  dotnet  CLI tooling even if your application is targetting Full Framework. For detailed instructions on installing .Net Core visit  official step-by-step installation guide    VSCode C# plugin (optional) - Ionide's debugging capabilities relies on the debugger provided by Omnisharp team. To get it install  C# extension from VSCode marketplace    MsBuild 2015 (Windows only, optional) - For old, verbose  .fsproj  files on Windows MsBuild 2015 (14.0) needs to be additionally installed. You can download it  here . However, we highly recommend using new, SDK-based project files.",
            "title": "Requirements"
        },
        {
            "location": "/#plugin-installation",
            "text": "Any VSCode extension can be installed using UI just inside VSCode. Bring up the Extensions view by clicking on the Extensions icon in the Activity Bar on the side of VS Code or the  View: Extensions  command ( Ctrl+Shift+X ). Then in search box type  Ionide  to find all 3 extensions we provide. Click the  Install  button and after a successful install, you'll see an  Reload  button which will prompt you to restart VS Code to enable the new extension. For more detailed information about plugin installation visit  VSCode documentation",
            "title": "Plugin installation"
        },
        {
            "location": "/#plugin-activation",
            "text": "VSCode plugins are running in external processes (which means they should never impact editor performance) and are activated lazily, when certain activation events happens. This means that plugins are not loaded unnecesserly, for example when you don't work on project using given programming language.  Ionide plugins are activated when:    Opened workspace contains any  .fsproj ,  .fs , or  .fsx  file    New  .fsproj ,  .fs , or  .fsx  file is created in workspace that was not containing those files before.",
            "title": "Plugin activation"
        },
        {
            "location": "/general/",
            "text": "General information\n\n\nIonide is complex tool with many options, and powerful capabilities, supporting multiple scenarios available to F# developers. As such is crucial to learn some general information about Ionide's requirements, and different configuration options that should be used depending on the different runtime and environments that can be used.\n\n\nGetting Requirements\n\n\n\n\n\n\nF# (Windows) - Easiest way to install latest versions of F# on Windows is using \nVS Build Tools 2017\n. If you use VS 2017, make sure that you've installed workload adding F# support.\n\n\n\n\n\n\nF# (Linux/MacOS) - F# on non-Windows platform is distributed as part of the \nmono\n. Installation guide and recent version of \nmono\n can be found on the \nproject webpage\n and on the F# Software Foundation \n\"Use on Linux\" page\n\n\n\n\n\n\n.Net Core SDK - .Net Core is modern, cross platform implementation of .Net Framework. Ionide is requiring it for set of features such as project modifications or debugging. The core part of SDK is \ndotnet\n CLI tool that provides easy way to create, build and run F# projects. What's important - the \ndotnet\n tool can be used also to create applications targeting also Full Framewok (like \nnet461\n). For detailed instructions on installing .Net Core visit \nofficial step-by-step installation guide\n\n\n\n\n\n\nVSCode C# plugin (optional) - Ionide's debugging capabilities relies on the debugger provided by Omnisharp team. To get it install \nC# extension from VSCode marketplace\n\n\n\n\n\n\nMsBuild 2015 (Windows only, optional) - For old, verbose \n.fsproj\n files on Windows MsBuild 2015 (14.0) needs to be additionally installed. You can download it \nhere\n. However, we highly recommend using new, SDK-based project files.\n\n\n\n\n\n\nProject files parsing\n\n\nIonide supports both old, verbose project files, and new SDK based files. However, we \nstrongly recommend\n using SDK based project files. Plugin is also supporting parsing \n.sln\n files. When you open VSCode in particular workspace, Ionide will try to find all \n.sln\n files in this workspace and you will be presented with the option to open particular solution, or ignore solution files and load all projects in the solution.\n\n\n\n\nWhen Ionide detects any F# projects it will display them in the \nSolution Explorer\n. To access it you need to press F# logo button on the activity bar. In there you will see list of F# projects, their status, list of file and references. You can also right-click on different nodes in the tree to access operations that can be performed by the Ionide, such as \nBuild Project\n or \nAdd file\n.\n\n\n\n\n\n\nNOTE: In case of the problems with project parsing (Projects in status \nloading failed\n) you can right-click on the project node and use \nShow Project Status\n to see more details about the problem. We also recommend using \nF#: Clear Cache\n action and reloading the window, as first step in debugging any problems.\n\n\n\n\nFsAutoComplete Service Runtime\n\n\nThe Ionide plugin relies on the F# compiler services for processing code in the editor.  The compiler services can run under the full framework (requiring \nmono\n on non-Windows platforms) or they can run under .NET Core as of Ionide 3.13.0.  This experimental feature can be enabled in the user settings.\n\n\nPreferences > Settings\n and add a new setting\n\n\n\"FSharp.fsacRuntime\": \"netcore\"\n\n\n\n\nThere are two options:\n\n\n\n\nnet\n (default) full framework\n\n\nnetcore\n .NET Core framework\n\n\n\n\nAfter updating this setting, execute the \nReload Window\n command in VS Code for the setting to take effect.\n\n\n\n\nNOTE: projects that use functionality incompatible with .NET Core, such as type providers, require this be set to \nnet\n in order for the F# Autocomplete Service to process code using these features.\n\n\n\n\nMsBuild Host\n\n\nThe Ionide plugin provides deep integration with MsBuild - starting from project parsing (process of getting list of files, references and properties out of \nfsproj\n file) through project modifications (adding new files, ordering them, adding project-to-project references) to building and running projects. All features provided by Ionide in area of project management are described more in \nProject\n section.\n\n\nIonide can use either MsBuild installation provided by Full Framework (installed by VS / VS Build Tools on Windows and by Mono on Linux/MacOS) or the cross platform version of MsBuild provided by .Net Core SDK. In most cases Ionide makes automatic decision which one to use based on the type of project file, but projects that use functionality incompatible with .NET Core, such as type providers not updated to latest TP SDK, require using Full Framework installation of MsBuild.\n\n\nTo control MsBuild Host that's used by Ionide you need to go to the F# Solution Explorer view and use \nF#: Pick MsBuild Host\n action",
            "title": "General info"
        },
        {
            "location": "/general/#general-information",
            "text": "Ionide is complex tool with many options, and powerful capabilities, supporting multiple scenarios available to F# developers. As such is crucial to learn some general information about Ionide's requirements, and different configuration options that should be used depending on the different runtime and environments that can be used.",
            "title": "General information"
        },
        {
            "location": "/general/#getting-requirements",
            "text": "F# (Windows) - Easiest way to install latest versions of F# on Windows is using  VS Build Tools 2017 . If you use VS 2017, make sure that you've installed workload adding F# support.    F# (Linux/MacOS) - F# on non-Windows platform is distributed as part of the  mono . Installation guide and recent version of  mono  can be found on the  project webpage  and on the F# Software Foundation  \"Use on Linux\" page    .Net Core SDK - .Net Core is modern, cross platform implementation of .Net Framework. Ionide is requiring it for set of features such as project modifications or debugging. The core part of SDK is  dotnet  CLI tool that provides easy way to create, build and run F# projects. What's important - the  dotnet  tool can be used also to create applications targeting also Full Framewok (like  net461 ). For detailed instructions on installing .Net Core visit  official step-by-step installation guide    VSCode C# plugin (optional) - Ionide's debugging capabilities relies on the debugger provided by Omnisharp team. To get it install  C# extension from VSCode marketplace    MsBuild 2015 (Windows only, optional) - For old, verbose  .fsproj  files on Windows MsBuild 2015 (14.0) needs to be additionally installed. You can download it  here . However, we highly recommend using new, SDK-based project files.",
            "title": "Getting Requirements"
        },
        {
            "location": "/general/#project-files-parsing",
            "text": "Ionide supports both old, verbose project files, and new SDK based files. However, we  strongly recommend  using SDK based project files. Plugin is also supporting parsing  .sln  files. When you open VSCode in particular workspace, Ionide will try to find all  .sln  files in this workspace and you will be presented with the option to open particular solution, or ignore solution files and load all projects in the solution.   When Ionide detects any F# projects it will display them in the  Solution Explorer . To access it you need to press F# logo button on the activity bar. In there you will see list of F# projects, their status, list of file and references. You can also right-click on different nodes in the tree to access operations that can be performed by the Ionide, such as  Build Project  or  Add file .    NOTE: In case of the problems with project parsing (Projects in status  loading failed ) you can right-click on the project node and use  Show Project Status  to see more details about the problem. We also recommend using  F#: Clear Cache  action and reloading the window, as first step in debugging any problems.",
            "title": "Project files parsing"
        },
        {
            "location": "/general/#fsautocomplete-service-runtime",
            "text": "The Ionide plugin relies on the F# compiler services for processing code in the editor.  The compiler services can run under the full framework (requiring  mono  on non-Windows platforms) or they can run under .NET Core as of Ionide 3.13.0.  This experimental feature can be enabled in the user settings.  Preferences > Settings  and add a new setting  \"FSharp.fsacRuntime\": \"netcore\"  There are two options:   net  (default) full framework  netcore  .NET Core framework   After updating this setting, execute the  Reload Window  command in VS Code for the setting to take effect.   NOTE: projects that use functionality incompatible with .NET Core, such as type providers, require this be set to  net  in order for the F# Autocomplete Service to process code using these features.",
            "title": "FsAutoComplete Service Runtime"
        },
        {
            "location": "/general/#msbuild-host",
            "text": "The Ionide plugin provides deep integration with MsBuild - starting from project parsing (process of getting list of files, references and properties out of  fsproj  file) through project modifications (adding new files, ordering them, adding project-to-project references) to building and running projects. All features provided by Ionide in area of project management are described more in  Project  section.  Ionide can use either MsBuild installation provided by Full Framework (installed by VS / VS Build Tools on Windows and by Mono on Linux/MacOS) or the cross platform version of MsBuild provided by .Net Core SDK. In most cases Ionide makes automatic decision which one to use based on the type of project file, but projects that use functionality incompatible with .NET Core, such as type providers not updated to latest TP SDK, require using Full Framework installation of MsBuild.  To control MsBuild Host that's used by Ionide you need to go to the F# Solution Explorer view and use  F#: Pick MsBuild Host  action",
            "title": "MsBuild Host"
        },
        {
            "location": "/editing/",
            "text": "Editing evolved\n\n\nIonide provides variety of language features known from more IDEs such as VS, and set of innovative features that makes you more productive then ever when writing F# code like CodeLenses, integration with FSharpLint and Quick Fixes.\n\n\nBasic features\n\n\nFollowing documentation is basic overview of features from Ionide's point of view. If you want to learn more about capabilities of VSCode visit \nofficial documentation\n. We strongly recommend exploring detailed VSCode documentation, especially if you've never worked with similar (Atom, ST3) editor before.\n\n\nIntelliSense\n\n\nIf Ionide knows possible completions, the IntelliSense suggestions will pop up as you type. If you continue typing characters, the list of members (variables, methods, etc.) is filtered to include only members containing your typed characters. Pressing \nTab\n or \nEnter\n will insert the selected member.\n\n\nYou can trigger IntelliSense in any editor window by typing \nCtrl+Space\n or by typing a trigger character (such as the dot character (\n.\n)).\n\n\n\n\nTip: The suggestions widget supports CamelCase filtering meaning you can type the letters which are upper cased in a method name to limit the suggestions. For example, \"cra\" will quickly bring up \"createApplication\".\n\n\n\n\nAdditionally, Ionide provides autocompletion for symbols not defined in currently opened modules and namespaces. If you accept such completion with \nTab\n or \nEnter\n it will automatically insert appropriate \nopen\n statement. This behavior is controlled by \nFSharp.externalAutocomplete\n setting (default value is \ntrue\n).\n\n\n\n\nAdditionally, you can see quick info for each method by either pressing \nCtrl+Space\n or clicking the info icon. The accompanying documentation for the method will now expand to the side. The expanded documentation will stay so and will update as you navigate the list. You can close this by pressing \nCtrl+Space\n again or by clicking on the close icon.\n\n\n\n\nTooltips\n\n\nIonide provides rich information about the symbols you hover on - structured signature and nicely formatted documentation text supporting markdown inside of the comments and transforming standard XML comment tags into markdown representation.\n\n\n\n\nTip: If you press \nCtrl\n while hovering Ionide will also put the body of the symbol in the tooltip.\n\n\n\n\n\n\nError highlighting\n\n\nIonide provides fast error highlighting for local changes, changes in current project and cross project changes without any need to build projects. Error highlighting for current projects works as you edit code, it supports files not saved to disk. For cross project error reporting you need to save the file - it will queue background project type checking which will provide errors asynchronously without blocking any editor operations.\n\n\nErrors in VSCode are shown in multiple places:\n\n In the status bar, there is a summary of all errors and warnings counts.\n\n You can click on the summary or press \nCtrl+Shift+M\n to display the \nPROBLEMS\n panel with a list of all current errors.\n* If you open a file that has errors or warnings, they will be rendered inline with the text and in the overview ruler.\n\n\n\n\nTip: To loop through errors or warnings in the current file, you can press \nF8\n or \nShift+F8\n which will show an inline zone detailing the problem and possible code actions (if available).\n\n\n\n\n\n\nCodeLens and LineLens\n\n\nIonide displays type signatures of the symbols either as information over the symbol (inserting virtual line) or as inlined information next to symbol. The behavior is customizable with \neditor.codeLens\n, \nFSharp.lineLens.enabled\n and \nFSharp.lineLens.*\n settings.\n\n\nQuick Info panel\n\n\nYou can check the type of symbol on which cursor currently is in the left part of VSCode Status Bar (bottom bar with different additional information about current position and file)\n\n\nGenerate record stubs\n\n\nYou can generate record stubs by using the \nQuick Fix\n feature (Default keyboard shortcut is \nCtrl+.\n). The feature is activated in two ways:\n\n\n\n\nUsing a type hint \nlet p : Person = { }\n with the cursor over \nPerson\n\n\nStarting to type the fields of the record\n\n\n\n\n\n\nCode navigation\n\n\nVisual Studio Code has a high productivity code editor which, when combined with programming language services, gives you the power of an IDE and the speed of a text editor. In this part we will show different ways of navigating around the code.\n\n\nGo to definition\n\n\nIonide provides going to symbol definition. You can do that by pressing \nF12\n, pressing right click on symbol and choosing \nGo to definition\n or by using \nCtrl+Click\n or running \nGo to definition\n from Command Palette.\n\n\n\n\nTip: You can use \nCtrl+Alt+Click\n or open the definition to the side in additional editor panel.\n\n\n\n\nGo to type definition\n\n\nIonide provides going to definition of the type of current symbol if the type was defined in local workspace. You can do that by running the \nGo to Type Definition\n command from either the editor context menu or the Command Palette.\n\n\n\n\nTip: The command \neditor.action.goToTypeDefinition\n is not bound to a keyboard shortcut by default but you can add your own custom keybinding.\n\n\n\n\nGo to symbol in file\n\n\nYou can navigate symbols inside a file with \nCtrl+Shift+O\n. Just press \nUp\n or \nDown\n and navigate to the place you want.\n\n\n\n\nTip: By typing \n:\n the symbols will be grouped by category.\n\n\n\n\nGo to symbol in workspace\n\n\nIonide support jumping to a symbol across files with \nCtrl+T\n. Just type the first letter of a symbol you want to navigate to, regardless of which file contains it, and press \nEnter\n.\n\n\n\n\nFind all references & Peek definition\n\n\nIonide also implements providers for finding all references (\nShift+F12\n) of the symbol in currently open solution and peeking definition of the symbol (\nAlt+F12\n). VSCode provides peeked editors which enables you to see the source code of the other file inlined without switching context. You can navigate between different references in the peeked editor and make quick edits right there. Clicking on the peeked editor filename or double-clicking in the result list will open the reference in the outer editor.\n\n\n\n\nBracket matching\n\n\nMatching brackets will be highlighted as soon as the cursor is near one of them.\n\n\n\n\nTip: You can jump to the matching bracket with \nCtrl+Shift+\\\n\n\n\n\nGo to next symbol usage\n\n\nUsages of symbol in current file will be highlighted as soon as the cursor is on the symbol.\n\n\n\n\nTip: You can jump to the next/previous usage with \nF7\n and \nShift+F7\n\n\n\n\nGo to MSDN help\n\n\nIonide provides command for opening MSDN documentation for given symbol. It works only for symbols from F# standard library, and .Net standard library. You can execute command with \nShift+F1\n or from Command Palette (\nF#: Get Help\n).\n\n\nCodeOutline panel\n\n\nIonide provides live updated panel showing symbols in current file. It's available as a additional tree view (\nF# Code Outline\n) in VSCode Explorer panel. On the panel you can notice 2 buttons - right one collapse (\nClick\n) or extends (\nAlt+Click\n) all elements in the tree, left one refreshes default collapsing (only modules and namespaces extended, types collapsed).\n\n\n\n\nTip: Clicking on any node in the tree will move you to the place in file where symbol is defined. It's really useful for navigating around huge files.\n\n\n\n\n\n\nAdvanced analyzers\n\n\nFSharpLint integration\n\n\nUnused value analyzer\n\n\nUnnecessary open statement analyzer\n\n\nSimplify name analyzer\n\n\nRefactoring\n\n\nRename symbol\n\n\nQuick fixes\n\n\nGenerate comment scaffold",
            "title": "Editing evolved"
        },
        {
            "location": "/editing/#editing-evolved",
            "text": "Ionide provides variety of language features known from more IDEs such as VS, and set of innovative features that makes you more productive then ever when writing F# code like CodeLenses, integration with FSharpLint and Quick Fixes.",
            "title": "Editing evolved"
        },
        {
            "location": "/editing/#basic-features",
            "text": "Following documentation is basic overview of features from Ionide's point of view. If you want to learn more about capabilities of VSCode visit  official documentation . We strongly recommend exploring detailed VSCode documentation, especially if you've never worked with similar (Atom, ST3) editor before.",
            "title": "Basic features"
        },
        {
            "location": "/editing/#intellisense",
            "text": "If Ionide knows possible completions, the IntelliSense suggestions will pop up as you type. If you continue typing characters, the list of members (variables, methods, etc.) is filtered to include only members containing your typed characters. Pressing  Tab  or  Enter  will insert the selected member.  You can trigger IntelliSense in any editor window by typing  Ctrl+Space  or by typing a trigger character (such as the dot character ( . )).   Tip: The suggestions widget supports CamelCase filtering meaning you can type the letters which are upper cased in a method name to limit the suggestions. For example, \"cra\" will quickly bring up \"createApplication\".   Additionally, Ionide provides autocompletion for symbols not defined in currently opened modules and namespaces. If you accept such completion with  Tab  or  Enter  it will automatically insert appropriate  open  statement. This behavior is controlled by  FSharp.externalAutocomplete  setting (default value is  true ).   Additionally, you can see quick info for each method by either pressing  Ctrl+Space  or clicking the info icon. The accompanying documentation for the method will now expand to the side. The expanded documentation will stay so and will update as you navigate the list. You can close this by pressing  Ctrl+Space  again or by clicking on the close icon.",
            "title": "IntelliSense"
        },
        {
            "location": "/editing/#tooltips",
            "text": "Ionide provides rich information about the symbols you hover on - structured signature and nicely formatted documentation text supporting markdown inside of the comments and transforming standard XML comment tags into markdown representation.   Tip: If you press  Ctrl  while hovering Ionide will also put the body of the symbol in the tooltip.",
            "title": "Tooltips"
        },
        {
            "location": "/editing/#error-highlighting",
            "text": "Ionide provides fast error highlighting for local changes, changes in current project and cross project changes without any need to build projects. Error highlighting for current projects works as you edit code, it supports files not saved to disk. For cross project error reporting you need to save the file - it will queue background project type checking which will provide errors asynchronously without blocking any editor operations.  Errors in VSCode are shown in multiple places:  In the status bar, there is a summary of all errors and warnings counts.  You can click on the summary or press  Ctrl+Shift+M  to display the  PROBLEMS  panel with a list of all current errors.\n* If you open a file that has errors or warnings, they will be rendered inline with the text and in the overview ruler.   Tip: To loop through errors or warnings in the current file, you can press  F8  or  Shift+F8  which will show an inline zone detailing the problem and possible code actions (if available).",
            "title": "Error highlighting"
        },
        {
            "location": "/editing/#codelens-and-linelens",
            "text": "Ionide displays type signatures of the symbols either as information over the symbol (inserting virtual line) or as inlined information next to symbol. The behavior is customizable with  editor.codeLens ,  FSharp.lineLens.enabled  and  FSharp.lineLens.*  settings.",
            "title": "CodeLens and LineLens"
        },
        {
            "location": "/editing/#quick-info-panel",
            "text": "You can check the type of symbol on which cursor currently is in the left part of VSCode Status Bar (bottom bar with different additional information about current position and file)",
            "title": "Quick Info panel"
        },
        {
            "location": "/editing/#generate-record-stubs",
            "text": "You can generate record stubs by using the  Quick Fix  feature (Default keyboard shortcut is  Ctrl+. ). The feature is activated in two ways:   Using a type hint  let p : Person = { }  with the cursor over  Person  Starting to type the fields of the record",
            "title": "Generate record stubs"
        },
        {
            "location": "/editing/#code-navigation",
            "text": "Visual Studio Code has a high productivity code editor which, when combined with programming language services, gives you the power of an IDE and the speed of a text editor. In this part we will show different ways of navigating around the code.",
            "title": "Code navigation"
        },
        {
            "location": "/editing/#go-to-definition",
            "text": "Ionide provides going to symbol definition. You can do that by pressing  F12 , pressing right click on symbol and choosing  Go to definition  or by using  Ctrl+Click  or running  Go to definition  from Command Palette.   Tip: You can use  Ctrl+Alt+Click  or open the definition to the side in additional editor panel.",
            "title": "Go to definition"
        },
        {
            "location": "/editing/#go-to-type-definition",
            "text": "Ionide provides going to definition of the type of current symbol if the type was defined in local workspace. You can do that by running the  Go to Type Definition  command from either the editor context menu or the Command Palette.   Tip: The command  editor.action.goToTypeDefinition  is not bound to a keyboard shortcut by default but you can add your own custom keybinding.",
            "title": "Go to type definition"
        },
        {
            "location": "/editing/#go-to-symbol-in-file",
            "text": "You can navigate symbols inside a file with  Ctrl+Shift+O . Just press  Up  or  Down  and navigate to the place you want.   Tip: By typing  :  the symbols will be grouped by category.",
            "title": "Go to symbol in file"
        },
        {
            "location": "/editing/#go-to-symbol-in-workspace",
            "text": "Ionide support jumping to a symbol across files with  Ctrl+T . Just type the first letter of a symbol you want to navigate to, regardless of which file contains it, and press  Enter .",
            "title": "Go to symbol in workspace"
        },
        {
            "location": "/editing/#find-all-references-peek-definition",
            "text": "Ionide also implements providers for finding all references ( Shift+F12 ) of the symbol in currently open solution and peeking definition of the symbol ( Alt+F12 ). VSCode provides peeked editors which enables you to see the source code of the other file inlined without switching context. You can navigate between different references in the peeked editor and make quick edits right there. Clicking on the peeked editor filename or double-clicking in the result list will open the reference in the outer editor.",
            "title": "Find all references &amp; Peek definition"
        },
        {
            "location": "/editing/#bracket-matching",
            "text": "Matching brackets will be highlighted as soon as the cursor is near one of them.   Tip: You can jump to the matching bracket with  Ctrl+Shift+\\",
            "title": "Bracket matching"
        },
        {
            "location": "/editing/#go-to-next-symbol-usage",
            "text": "Usages of symbol in current file will be highlighted as soon as the cursor is on the symbol.   Tip: You can jump to the next/previous usage with  F7  and  Shift+F7",
            "title": "Go to next symbol usage"
        },
        {
            "location": "/editing/#go-to-msdn-help",
            "text": "Ionide provides command for opening MSDN documentation for given symbol. It works only for symbols from F# standard library, and .Net standard library. You can execute command with  Shift+F1  or from Command Palette ( F#: Get Help ).",
            "title": "Go to MSDN help"
        },
        {
            "location": "/editing/#codeoutline-panel",
            "text": "Ionide provides live updated panel showing symbols in current file. It's available as a additional tree view ( F# Code Outline ) in VSCode Explorer panel. On the panel you can notice 2 buttons - right one collapse ( Click ) or extends ( Alt+Click ) all elements in the tree, left one refreshes default collapsing (only modules and namespaces extended, types collapsed).   Tip: Clicking on any node in the tree will move you to the place in file where symbol is defined. It's really useful for navigating around huge files.",
            "title": "CodeOutline panel"
        },
        {
            "location": "/editing/#advanced-analyzers",
            "text": "",
            "title": "Advanced analyzers"
        },
        {
            "location": "/editing/#fsharplint-integration",
            "text": "",
            "title": "FSharpLint integration"
        },
        {
            "location": "/editing/#unused-value-analyzer",
            "text": "",
            "title": "Unused value analyzer"
        },
        {
            "location": "/editing/#unnecessary-open-statement-analyzer",
            "text": "",
            "title": "Unnecessary open statement analyzer"
        },
        {
            "location": "/editing/#simplify-name-analyzer",
            "text": "",
            "title": "Simplify name analyzer"
        },
        {
            "location": "/editing/#refactoring",
            "text": "",
            "title": "Refactoring"
        },
        {
            "location": "/editing/#rename-symbol",
            "text": "",
            "title": "Rename symbol"
        },
        {
            "location": "/editing/#quick-fixes",
            "text": "",
            "title": "Quick fixes"
        },
        {
            "location": "/editing/#generate-comment-scaffold",
            "text": "",
            "title": "Generate comment scaffold"
        },
        {
            "location": "/project/",
            "text": "Project managment\n\n\nGeneral information\n\n\nProject explorere\n\n\nMsBuild integration",
            "title": "Project managment"
        },
        {
            "location": "/project/#project-managment",
            "text": "General information",
            "title": "Project managment"
        },
        {
            "location": "/project/#project-explorere",
            "text": "",
            "title": "Project explorere"
        },
        {
            "location": "/project/#msbuild-integration",
            "text": "",
            "title": "MsBuild integration"
        },
        {
            "location": "/debugger/",
            "text": "Debugging\n\n\nRequirements\n\n\n\n\n\n\nVSCode C# plugin (Omnisharp)\n\n\n\n\n\n\nWorks for projects using new, SDK-based project files\n\n\n\n\n\n\nPortable PDB",
            "title": "Debugging"
        },
        {
            "location": "/debugger/#debugging",
            "text": "",
            "title": "Debugging"
        },
        {
            "location": "/debugger/#requirements",
            "text": "VSCode C# plugin (Omnisharp)    Works for projects using new, SDK-based project files    Portable PDB",
            "title": "Requirements"
        },
        {
            "location": "/paket/",
            "text": "Paket Integration",
            "title": "Paket integration"
        },
        {
            "location": "/paket/#paket-integration",
            "text": "",
            "title": "Paket Integration"
        },
        {
            "location": "/fake/",
            "text": "FAKE integration",
            "title": "FAKE integration"
        },
        {
            "location": "/fake/#fake-integration",
            "text": "",
            "title": "FAKE integration"
        },
        {
            "location": "/commands/",
            "text": "List of commands",
            "title": "List of commands"
        },
        {
            "location": "/commands/#list-of-commands",
            "text": "",
            "title": "List of commands"
        },
        {
            "location": "/options/",
            "text": "List of options\n\n\nF# Plugin options\n\n\nFSharp.fsacRuntime\n\n\nChoose the runtime of FsAutoComplete (FSAC). Require restart\n\n\nPossible values:\n\n\n\n\n\n\nnet\n - run FSAC using Full Framework (mono on non-Windows)\n\n\n\n\n\n\nnetcore\n (\nExperimental\n) - run FSAC using .Net Core.\n\n\n\n\n\n\nDefault value:\n \nnet\n\n\n\n\nFSharp.workspaceMode\n\n\nChoose the workspace mode - way in which projects are detected in currently opened folder.\n\n\nPossible values:\n\n\n\n\n\n\nsln\n - Tries to detecl \n.sln\n file in current workspace. If there are more than one \n.sln\n files user will be asked which one to use. If there is no \n.sln\n file in workspace service will fallback to \ndirectory\n mode. Search performed by FSAC using \nFSharp.workspaceModePeekDeepLevel\n setting.\n\n\n\n\n\n\ndirectory\n - Ionide loads all detected projects in the directory. Search performed by FSAC using \nFSharp.workspaceModePeekDeepLevel\n setting.\n\n\n\n\n\n\nionideSearch\n - Ionide loads all detected projects in the directory. Search performed by Ionide - it was default mode pre-3.0.0 version.\n\n\n\n\n\n\nDefault value:\n \nsln\n\n\n\n\nFSharp.workspaceModePeekDeepLevel\n\n\nDefines the depth level of directory hierarchy when searching for sln/projects\n\n\nPossible values:\n \n[0...99]\n\n\nDefault value:\n \n2\n\n\n\n\nFSharp.workspaceLoader\n\n\nChoose way the FSAC loads projects\n\n\nPossible values:\n\n\n\n\n\n\nprojects\n - loading projects is invoked by \nproject\n request from Ionide. It's done synchronusly, one-by-one on the plugin startup. Using \nProjectCracker\n for non-SDK projects, \ndotnet-project-info\n for SDK based projects.\n\n\n\n\n\n\nworkspaceLoad\n (\nExperimental\n) - loading projects is triggered by \nworkspaceLoad\n request from Ionide. Process is done asynchronusly, notifications are pushed by FSAC to Ionide through web sockets.\n\n\n\n\n\n\nDefault value:\n \nprojects\n\n\n\n\nFSharp.logLanguageServiceRequests\n\n\nEnable logging for F# Language Service requests (FSAC) to either an output channel, the developer tools console, or both\n\n\nPossible values:\n\n\n\n\n\n\nnone\n - turns off logging\n\n\n\n\n\n\noutput\n - logs to output channel\n\n\n\n\n\n\ndevconsole\n - logs to developer console\n\n\n\n\n\n\nboth\n - logs to both output channel and developer console\n\n\n\n\n\n\nDefault value:\n \noutput\n\n\n\n\nFSharp.logLanguageServiceRequestsOutputWindowLevel\n\n\nSet the verbosity for F# Language Service Output Channel\n\n\nPossible values:\n\n\n\n\n\n\nDEBUG\n\n\n\n\n\n\nINFO\n\n\n\n\n\n\nWARN\n\n\n\n\n\n\nERROR\n\n\n\n\n\n\nDefault value:\n \nINFO\n\n\n\n\nFSharp.toolsDirPath\n\n\nThe directory containing the F# tools\n\n\nPossible values:\n any string\n\n\nDefault value:\n \n\"\"\n\n\n\n\nFSharp.monoPath\n\n\nThe path to Mono executable\n\n\nPossible values:\n any string\n\n\nDefault value:\n \nmono\n\n\n\n\nFSharp.fsiFilePath\n\n\nThe path to the F# Interactive tool used by Ionide-FSharp. Useful for setting 64-bits FSI in some cases.\n\n\nPossible values:\n any string\n\n\nDefault value:\n \n\"\"\n\n\n\n\nFSharp.keywordsAutocomplete\n\n\nIncludes keywords in autocomplete\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nFSharp.externalAutocomplete\n\n\nIncludes external (from unopen modules and namespaces) symbols in autocomplete. Automatically adds open statements.\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nFSharp.linter\n\n\nEnables integration with FSharpLinter (additional warnings and refactorings)\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nFSharp.unusedOpensAnalyzer\n\n\nEnables detection of unused opens, provides quick fix.\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nFSharp.unusedDeclarationsAnalyzer\n\n\nEnables detection of unused declarations, provides quick fix.\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nFSharp.simplifyNameAnalyzer\n\n\nEnables detection of symbols usages that can be simplified, provides quick fix.\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nFSharp.resolveNamespaces\n\n\nEnables \nresolve unopened namespaces and modules\n code fix.\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nFSharp.fsiExtraParameters\n\n\nAllows to pass extra parameters to FSI process\n\n\nPossible values:\n array of strings\n\n\nDefault value:\n \n[]\n\n\n\n\nFSharp.saveOnSendLastSelection\n\n\nSave Current file before send LastSelection to FSI\n\n\nPossible values:\n bool\n\n\nDefault value:\n \nfalse\n\n\n\n\nFSharp.msbuildLocation\n\n\nUse a specific version of msbuild to build this project.\n\n\nPossible values:\n string\n\n\nDefault value:\n \n\"\"\n\n\n\n\nFSharp.msbuildAutoshow\n\n\nAutomatically shows MsBuild output panel\n\n\nPossible values:\n bool\n\n\nDefault value:\n \nfalse\n\n\n\n\nFSharp.msbuildHost\n\n\nUse specific MSBuild host\n\n\nPossible values:\n\n\n\n\n\n\n.net\n - uses MsBuild installed by VS or MsBuild Tools\n\n\n\n\n\n\n.net core\n - uses \ndotnet msbuild\n\n\n\n\n\n\nask at first use\n - promts user to choose when first time needed\n\n\n\n\n\n\nauto\n - automatically choose host based on project file\n\n\n\n\n\n\nDefault value:\n \nauto\n\n\n\n\nFSharp.enableTreeView\n\n\nEnables solution explorer. Requires restart\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nFSharp.codeOutline\n\n\nEnables Code Outline tree view. Requires restart\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nFSharp.lineLens.enabled\n\n\nUsage mode for LineLens\n\n\nPossible values:\n\n\n\n\n\n\nnever\n - never show LineLenses\n\n\n\n\n\n\nreplaceCodeLens\n - show LineLenses if CodeLenses are disabled\n\n\n\n\n\n\nalways\n - always show LineLenses\n\n\n\n\n\n\nDefault value:\n \nnever\n\n\n\n\nFSharp.lineLens.prefix\n\n\nThe prefix displayed before the signature.\n\n\nPossible values:\n string\n\n\nDefault value:\n \n//\n\n\n\n\nFSharp.recordStubGeneration\n\n\nEnables record stub generation.\n\n\nPossible values:\n bool\n\n\nDefault value:\n \ntrue\n\n\n\n\nPaket Plugin options\n\n\nFAKE Plugin options",
            "title": "List of options"
        },
        {
            "location": "/options/#list-of-options",
            "text": "",
            "title": "List of options"
        },
        {
            "location": "/options/#f-plugin-options",
            "text": "",
            "title": "F# Plugin options"
        },
        {
            "location": "/options/#fsharpfsacruntime",
            "text": "Choose the runtime of FsAutoComplete (FSAC). Require restart  Possible values:    net  - run FSAC using Full Framework (mono on non-Windows)    netcore  ( Experimental ) - run FSAC using .Net Core.    Default value:   net",
            "title": "FSharp.fsacRuntime"
        },
        {
            "location": "/options/#fsharpworkspacemode",
            "text": "Choose the workspace mode - way in which projects are detected in currently opened folder.  Possible values:    sln  - Tries to detecl  .sln  file in current workspace. If there are more than one  .sln  files user will be asked which one to use. If there is no  .sln  file in workspace service will fallback to  directory  mode. Search performed by FSAC using  FSharp.workspaceModePeekDeepLevel  setting.    directory  - Ionide loads all detected projects in the directory. Search performed by FSAC using  FSharp.workspaceModePeekDeepLevel  setting.    ionideSearch  - Ionide loads all detected projects in the directory. Search performed by Ionide - it was default mode pre-3.0.0 version.    Default value:   sln",
            "title": "FSharp.workspaceMode"
        },
        {
            "location": "/options/#fsharpworkspacemodepeekdeeplevel",
            "text": "Defines the depth level of directory hierarchy when searching for sln/projects  Possible values:   [0...99]  Default value:   2",
            "title": "FSharp.workspaceModePeekDeepLevel"
        },
        {
            "location": "/options/#fsharpworkspaceloader",
            "text": "Choose way the FSAC loads projects  Possible values:    projects  - loading projects is invoked by  project  request from Ionide. It's done synchronusly, one-by-one on the plugin startup. Using  ProjectCracker  for non-SDK projects,  dotnet-project-info  for SDK based projects.    workspaceLoad  ( Experimental ) - loading projects is triggered by  workspaceLoad  request from Ionide. Process is done asynchronusly, notifications are pushed by FSAC to Ionide through web sockets.    Default value:   projects",
            "title": "FSharp.workspaceLoader"
        },
        {
            "location": "/options/#fsharploglanguageservicerequests",
            "text": "Enable logging for F# Language Service requests (FSAC) to either an output channel, the developer tools console, or both  Possible values:    none  - turns off logging    output  - logs to output channel    devconsole  - logs to developer console    both  - logs to both output channel and developer console    Default value:   output",
            "title": "FSharp.logLanguageServiceRequests"
        },
        {
            "location": "/options/#fsharploglanguageservicerequestsoutputwindowlevel",
            "text": "Set the verbosity for F# Language Service Output Channel  Possible values:    DEBUG    INFO    WARN    ERROR    Default value:   INFO",
            "title": "FSharp.logLanguageServiceRequestsOutputWindowLevel"
        },
        {
            "location": "/options/#fsharptoolsdirpath",
            "text": "The directory containing the F# tools  Possible values:  any string  Default value:   \"\"",
            "title": "FSharp.toolsDirPath"
        },
        {
            "location": "/options/#fsharpmonopath",
            "text": "The path to Mono executable  Possible values:  any string  Default value:   mono",
            "title": "FSharp.monoPath"
        },
        {
            "location": "/options/#fsharpfsifilepath",
            "text": "The path to the F# Interactive tool used by Ionide-FSharp. Useful for setting 64-bits FSI in some cases.  Possible values:  any string  Default value:   \"\"",
            "title": "FSharp.fsiFilePath"
        },
        {
            "location": "/options/#fsharpkeywordsautocomplete",
            "text": "Includes keywords in autocomplete  Possible values:  bool  Default value:   true",
            "title": "FSharp.keywordsAutocomplete"
        },
        {
            "location": "/options/#fsharpexternalautocomplete",
            "text": "Includes external (from unopen modules and namespaces) symbols in autocomplete. Automatically adds open statements.  Possible values:  bool  Default value:   true",
            "title": "FSharp.externalAutocomplete"
        },
        {
            "location": "/options/#fsharplinter",
            "text": "Enables integration with FSharpLinter (additional warnings and refactorings)  Possible values:  bool  Default value:   true",
            "title": "FSharp.linter"
        },
        {
            "location": "/options/#fsharpunusedopensanalyzer",
            "text": "Enables detection of unused opens, provides quick fix.  Possible values:  bool  Default value:   true",
            "title": "FSharp.unusedOpensAnalyzer"
        },
        {
            "location": "/options/#fsharpunuseddeclarationsanalyzer",
            "text": "Enables detection of unused declarations, provides quick fix.  Possible values:  bool  Default value:   true",
            "title": "FSharp.unusedDeclarationsAnalyzer"
        },
        {
            "location": "/options/#fsharpsimplifynameanalyzer",
            "text": "Enables detection of symbols usages that can be simplified, provides quick fix.  Possible values:  bool  Default value:   true",
            "title": "FSharp.simplifyNameAnalyzer"
        },
        {
            "location": "/options/#fsharpresolvenamespaces",
            "text": "Enables  resolve unopened namespaces and modules  code fix.  Possible values:  bool  Default value:   true",
            "title": "FSharp.resolveNamespaces"
        },
        {
            "location": "/options/#fsharpfsiextraparameters",
            "text": "Allows to pass extra parameters to FSI process  Possible values:  array of strings  Default value:   []",
            "title": "FSharp.fsiExtraParameters"
        },
        {
            "location": "/options/#fsharpsaveonsendlastselection",
            "text": "Save Current file before send LastSelection to FSI  Possible values:  bool  Default value:   false",
            "title": "FSharp.saveOnSendLastSelection"
        },
        {
            "location": "/options/#fsharpmsbuildlocation",
            "text": "Use a specific version of msbuild to build this project.  Possible values:  string  Default value:   \"\"",
            "title": "FSharp.msbuildLocation"
        },
        {
            "location": "/options/#fsharpmsbuildautoshow",
            "text": "Automatically shows MsBuild output panel  Possible values:  bool  Default value:   false",
            "title": "FSharp.msbuildAutoshow"
        },
        {
            "location": "/options/#fsharpmsbuildhost",
            "text": "Use specific MSBuild host  Possible values:    .net  - uses MsBuild installed by VS or MsBuild Tools    .net core  - uses  dotnet msbuild    ask at first use  - promts user to choose when first time needed    auto  - automatically choose host based on project file    Default value:   auto",
            "title": "FSharp.msbuildHost"
        },
        {
            "location": "/options/#fsharpenabletreeview",
            "text": "Enables solution explorer. Requires restart  Possible values:  bool  Default value:   true",
            "title": "FSharp.enableTreeView"
        },
        {
            "location": "/options/#fsharpcodeoutline",
            "text": "Enables Code Outline tree view. Requires restart  Possible values:  bool  Default value:   true",
            "title": "FSharp.codeOutline"
        },
        {
            "location": "/options/#fsharplinelensenabled",
            "text": "Usage mode for LineLens  Possible values:    never  - never show LineLenses    replaceCodeLens  - show LineLenses if CodeLenses are disabled    always  - always show LineLenses    Default value:   never",
            "title": "FSharp.lineLens.enabled"
        },
        {
            "location": "/options/#fsharplinelensprefix",
            "text": "The prefix displayed before the signature.  Possible values:  string  Default value:   //",
            "title": "FSharp.lineLens.prefix"
        },
        {
            "location": "/options/#fsharprecordstubgeneration",
            "text": "Enables record stub generation.  Possible values:  bool  Default value:   true",
            "title": "FSharp.recordStubGeneration"
        },
        {
            "location": "/options/#paket-plugin-options",
            "text": "",
            "title": "Paket Plugin options"
        },
        {
            "location": "/options/#fake-plugin-options",
            "text": "",
            "title": "FAKE Plugin options"
        },
        {
            "location": "/architecture/",
            "text": "Plugin architecture\n\n\nVSCode plugin\n\n\nFsAutoComplete\n\n\nF# Compiler services",
            "title": "Architecture"
        },
        {
            "location": "/architecture/#plugin-architecture",
            "text": "",
            "title": "Plugin architecture"
        },
        {
            "location": "/architecture/#vscode-plugin",
            "text": "",
            "title": "VSCode plugin"
        },
        {
            "location": "/architecture/#fsautocomplete",
            "text": "",
            "title": "FsAutoComplete"
        },
        {
            "location": "/architecture/#f-compiler-services",
            "text": "",
            "title": "F# Compiler services"
        },
        {
            "location": "/how-to-contribute/",
            "text": "How to contribute\n\n\nPrerequisites\n\n\n\n\nVisual Studio Code\n \ud83d\ude44\n\n\nMono\n\n\n.Net Core 2.0\n\n\nNode.js\n\n\nYarn\n\n\n\n\nBuilding\n\n\nFork, from the github interface https://github.com/ionide/ionide-vscode-fsharp\n - if you don't use a certificate for commiting to github:\n\n\ngit clone https://github.com/YOUR_GITHUB_USER/ionide-vscode-fsharp.git\n\n\n\n\n\n\nif you use a certificate for github authentication:\n\n\n\n\ngit clone git@github.com:YOUR_GITHUB_USER/ionide-vscode-fsharp.git\n\n\n\n\nFirst time build:\n\n\ncd ionide-vscode-fsharp\nyarn install\ndotnet restore\ncd src\ndotnet restore\ncd ..\n./build.sh  # or build.cmd if your OS is Windows\n\n\n\n\nEverything is done via \nbuild.cmd\n \\ \nbuild.sh\n.\n\n\n\n\nbuild Build\n does a full-build, including package installation and copying some necessary files.\n\n  It should always be done at least once after any clone/pull.\n\n\nIf a git dependency fail to build paket won't re-do it you can run their build scripts manually:\n\n\nIn \npaket-files\\github.com\\fsharp\\FsAutoComplete\n run \nbuild LocalRelease\n\n\nIn \npaket-files\\github.com\\fsharp-editing\\Forge\n run \nbuild Build\n\n\nIn VSCode two configurations are possible to run:\n\n\nUse \nBuild and Launch Extension\n\n\nStart the \nWatch\n task and when a build is done start \nLaunch Only\n\n\n\n\nWorking with FSAC\n\n\n\n\nRun \nbuild.cmd Build\n \\ \nbuild.sh Build\n\n\nOpen Ionide-vscode-fsharp in VSCode.\n\n\nSet \ndevMode\n to \ntrue\n in \nsrc/Core/LanguageService.fs\n\n\nOpen FSAC in VS\n\n\nStart FSAC.Suave in VS\n\n\nPress F5 in VSCode to build Ionide and start experimental instance",
            "title": "How to contribute"
        },
        {
            "location": "/how-to-contribute/#how-to-contribute",
            "text": "",
            "title": "How to contribute"
        },
        {
            "location": "/how-to-contribute/#prerequisites",
            "text": "Visual Studio Code  \ud83d\ude44  Mono  .Net Core 2.0  Node.js  Yarn",
            "title": "Prerequisites"
        },
        {
            "location": "/how-to-contribute/#building",
            "text": "Fork, from the github interface https://github.com/ionide/ionide-vscode-fsharp\n - if you don't use a certificate for commiting to github:  git clone https://github.com/YOUR_GITHUB_USER/ionide-vscode-fsharp.git   if you use a certificate for github authentication:   git clone git@github.com:YOUR_GITHUB_USER/ionide-vscode-fsharp.git",
            "title": "Building"
        },
        {
            "location": "/how-to-contribute/#first-time-build",
            "text": "cd ionide-vscode-fsharp\nyarn install\ndotnet restore\ncd src\ndotnet restore\ncd ..\n./build.sh  # or build.cmd if your OS is Windows  Everything is done via  build.cmd  \\  build.sh .   build Build  does a full-build, including package installation and copying some necessary files. \n  It should always be done at least once after any clone/pull.  If a git dependency fail to build paket won't re-do it you can run their build scripts manually:  In  paket-files\\github.com\\fsharp\\FsAutoComplete  run  build LocalRelease  In  paket-files\\github.com\\fsharp-editing\\Forge  run  build Build  In VSCode two configurations are possible to run:  Use  Build and Launch Extension  Start the  Watch  task and when a build is done start  Launch Only",
            "title": "First time build:"
        },
        {
            "location": "/how-to-contribute/#working-with-fsac",
            "text": "Run  build.cmd Build  \\  build.sh Build  Open Ionide-vscode-fsharp in VSCode.  Set  devMode  to  true  in  src/Core/LanguageService.fs  Open FSAC in VS  Start FSAC.Suave in VS  Press F5 in VSCode to build Ionide and start experimental instance",
            "title": "Working with FSAC"
        }
    ]
}